var store = [{
        "title": "OOC - Base",
        "excerpt":"Como utilizar OOC?   There are many ways to achieve object orientation in C. We will follow the approach used by Axel-Tobias Schreiner in his Object-Oriented Programming With ANSI-C book. In it we use hidden structs, void pointers, variatic functions and dynamic linkage to achieve object orientation.   One of the main differences of our method is that we will not be using a different preprocessor for our development. We will use the C preprocessor and MACROS to facilitate our development.   It’s really simple to starting using it, you just have to get the code for the base classes, the macros and some simple classes and interfaces and include what you will really use.   #include \"vector.h\" int main(){     o_Vector o_int_vector = VectorC(int);     Collection_inplaceAddAllC(o_string_vector, int, ARG({1, 2, 3, 4}));     o_Iterator o_iterator = Iterable_create(o_int_vector);     Collection_add(INT(5));     Collection_add(INT(6));     for_iterator(o_iterator){         int* p_int = Iterator_currItem(o_iterator);         if(p_int){             printf(\"%d,\", *p_int); // Will print out 1,2,3,4,5,6,         }     }     printf(\"\\n\");     OOC_DELETE(o_iterator);     OOC_DELETE(o_int_vector); }  ","categories": ["OOC"],
        "tags": ["c","OOC"],
        "url": "https://rodrigowerberich.github.io//ooc/base/br",
        "teaser":null},{
        "title": "OOC - Simple Class",
        "excerpt":"Creating a simple class   Let’s start by creating a simple class: the cat. A cat can be really simplified and be represented by a color, a weight, a length and a name. These will be our attributes.   A cat can “talk”, jump and eat, amongst other things. These will be our methods, or interfaces. With than we can begin building our cat class.   In OOC a class is defined by three files,      the public interface or .h file,   the reserved interface or .r file and   the implementation or .c file.   Public Interface  Let’s begin with the public interface, first we must create the class itself, for that we use the CLASS_DECLARATION macro.   // File: cat.h #ifndef CAT_H_ #define CAT_H_ #include \"ooc.h\"  CLASS_DECLARATION(Cat);  #endif /* CAT_H_ */  This macro creates the type o_Cat, which we will use to refer to cat objects, the descriptor Cat_d, which is a pointer to an object that knows how to build cat objects. A forward declaration of the void* initCat(), a function that creates the Cat_d descriptor (This function must be implemented in the implementation file). And the implementation of the automatic initializer inline const void* CatClass(), which is what we will use to access the descriptor.   The next step is to create the constructors of your class, to do that we create inline functions that makes cals to the ooc_new function.  ... // File: cat.h // Empty constructor static inline o_Cat Cat(){     return ooc_new(CatClass(), 0, 0.0, 0.0, NULL); } // Complete constructor static inline o_Cat CatSpecified(int color, double weight, double length, o_String o_name){     return ooc_new(CatClass(), color, weight, length, o_name); } ...  Now we must specify what our cat can do. We do it simply be creating functions that takes as the first parameter the class object. This is will be our methods:  ... void Cat_jump(o_Cat self, double distance); void Cat_eat(o_Cat self); o_String Cat_talk(o_Cat self);  ...  With that our basic class public interface file is complete!  #ifndef CAT_H_ #define CAT_H_ #include \"ooc.h\" #include \"o_string.h\" //---- Class declaration CLASS_DECLARATION(Cat); //----  Class constructor // Empty constructor static inline o_Cat Cat(){     return ooc_new(CatClass(), 0, 0.0, 0.0, NULL); } // Complete constructor static inline o_Cat CatSpecified(int color, double weight, double length, o_String o_name){     return ooc_new(CatClass(), color, weight, length, o_name); } //---- Methods // Static methods void Cat_jump(o_Cat self, double distance); void Cat_eat(o_Cat self); o_String Cat_talk(o_Cat self); #endif /* CAT_H_ */   Reserved Interface  Now we will build the restricted interface for the cat class, this is pretty simple. All we have to do is create the cat.r file, include the ooc.r file and the public interface file and implement the struct that represents our data.   Since our cat is described by it’s color, weight, length and name we create a struct Cat_r with this information.   #ifndef CAT_R__ #define CAT_R__  #include \"ooc.r\" #include \"cat.h\"  typedef struct Cat_r{     const Object_r  _;     int             color;     double           weight;     double           length;     o_String        o_name; }Cat_r;  #endif //CAT_R__   There are two very important things to notice in this struct.     The struct must be typedef’ed to create a new type. This new type must be the class name followed by _r!   The first element of the struct must be the base class representation of this class and must be called _!   You must follow these rules or polimorphism and the macros won’t work.   Now we can start with the implementation file   Implementation file   We’ll start implementing the static linked methods Cat_jump, Cat_eat and Cat_talk.   #include \"cat.h\" #include \"cat.r\" #include \"lua_assert.h\"  void Cat_jump(o_Cat _self, double distance){     CAST(self, Cat);     ASSERT(self,);     if( (4*self-&gt;length) &lt; distance ){         printf(\"Jumping %f meters\\n\", distance);     }else{         printf(\"Can't jump that far\\n\");     } } void Cat_eat(o_Cat _self){     CAST(self, Cat);     ASSERT(self, );     self-&gt;weight += 0.01; } o_String Cat_talk(o_Cat _self){     CAST(self, Cat);     ASSERT(self, NULL);     o_String o_talk = OOC_CLONE(self-&gt;o_name);     String_appendC(o_talk, \" says meow!\");     return o_talk; }   The class methods must always have the first argument called _self and it represents the object the method is applied to. To ensure that the class methods is being applied to the right object we should always use the CAST(name_, class_) macro. This macros verifies if a variable with name “_var_name” is a subclass of the Class specified and casts it into a pointer of Class_r. If the object is not a subclass the cast will return a pointer to NULL. That is why we use to ASSERT(assertion_, return_value_) macro to check if the pointer is valid and deal with the error appropriatly.   The base object has three overwritable functions the ooc_ctor (Constructor), the ooc_dtor(Destructor) and ooc_differ(Comparison).   The only one you must alway overwrite is the constructor. If the constructor allocates any memory, you must implement the destructor and if you wan’t to change the default comparison, which compares pointers, you must overwrite the comparison.   To do that you must use the OVERWRITE_METHOD(func_desc_) macro which takes in a function descriptor (this will be explained later). The function descriptors for the constructor, destructor and difference methods are, respectively, M_CTOR, M_DTOR and M_DIFFER.   So to implement the Cat constructor  static OVERWRITE_METHOD(Cat, M_CTOR){     SUPER_CTOR(self, Cat);     ASSERT(self, NULL);     self-&gt;color = CTOR_GET_PARAM(int);     self-&gt;weight = CTOR_GET_PARAM(double);     self-&gt;length = CTOR_GET_PARAM(double);     self-&gt;o_name = CTOR_GET_PARAM(o_String);     return self; }  The SUPER_CTOR(self, Cat); will call the super class constructor. If something is wrong the variable self will be set to NULL. The macro CTOR_GET_PARAM(type_) will return the next available parameter with the type passed from the variable list. You must retrieve the parameters exactly in the order passed by the constructor.   Since o_name is an object, the cat object is now responsible for its lifespan, so we must implement the destructor to free the resource when this object is destroyed.   static OVERWRITE_METHOD(Cat, M_DTOR){     SUPER_DTOR(self, Cat);     ASSERT(self, NULL);     OOC_DELETE(self-&gt;o_name);     return self; }   The SUPER_CTOR(self, Cat); will call the super class constructor. If something is wrong the variable self will be set to NULL.   Both the constructor and the destructor should alway return self, unless something wrong occurs, then it must return NULL.   To end the class implementation all we have to do is create the description class variable Cat_d and the class initializer initCat().   const void* Cat_d; const void* initCat(){     return ooc_new(\t             ClassClass(),               // MetaClass             \"Cat\",                      // Class name             ObjectClass(),              // Super class             sizeof(Cat_r),              // Size of representation structure             LINK_METHOD(Cat, M_CTOR),   // Linking the dynamic methods             LINK_METHOD(Cat, M_DTOR),             0); // Must alway ends with a zero }   The initCat() method is called by the CatClass() automatic initializer, which will assign the object created inside initCat to the Cat_d descriptor object. This object contains the blueprint to build Cat objects.   The end implementation file should be something like this:  #include \"cat.h\" #include \"cat.r\" #include \"lua_assert.h\"  // Static methods ------ void Cat_jump(o_Cat _self, double distance){     CAST(self, Cat);     ASSERT(self,);     if( (4*self-&gt;length) &lt; distance ){         printf(\"Jumping %f meters\\n\", distance);     }else{         printf(\"Can't jump that far\\n\");     } } void Cat_eat(o_Cat _self){     CAST(self, Cat);     ASSERT(self, );     self-&gt;weight += 0.01; } o_String Cat_talk(o_Cat _self){     CAST(self, Cat);     ASSERT(self, NULL);     o_String o_talk = OOC_CLONE(self-&gt;o_name);     String_appendC(o_talk, \" says meow!\");     return o_talk; }  // Dynamic methods ----------- // Overwriting object ----------- static OVERWRITE_METHOD(Cat, M_CTOR){     SUPER_CTOR(self, Cat);     ASSERT(self, NULL);     self-&gt;color = CTOR_GET_PARAM(int);     self-&gt;weight = CTOR_GET_PARAM(double);     self-&gt;length = CTOR_GET_PARAM(double);     self-&gt;o_name = CTOR_GET_PARAM(o_String);     return self; }  static OVERWRITE_METHOD(Cat, M_DTOR){     SUPER_DTOR(self, Cat);     ASSERT(self, NULL);     OOC_DELETE(self-&gt;o_name);     return self; }  // Descriptor and initializer const void* Cat_d; const void* initCat(){     return ooc_new(\t             ClassClass(),               // MetaClass             \"Cat\",                      // Class name             ObjectClass(),              // Super class             sizeof(Cat_r),              // Size of representation structure             LINK_METHOD(Cat, M_CTOR),   // Linking the dynamic methods             LINK_METHOD(Cat, M_DTOR),             0); // Must alway ends with a zero }   ","categories": ["OOC"],
        "tags": ["c","OOC","Classe"],
        "url": "https://rodrigowerberich.github.io//ooc/simple-class/br",
        "teaser":null},{
        "title": "OOC - Super Class",
        "excerpt":"Creating a super class  For this example we will create two classes, the Point and the Circle. The point has two atributtes, it’s x and y coordinates. And two methods, the move and draw methods.   To move the point we will only add the delta x, and delta y to the currents point position. To draw it we will only print “Point at x, y”   The circle follows the same principle, but it also has a radius. The move method does exactly the same, but the draw method must print “Circle with radius r at x,y” instead.   To do that we will implement the circle as a subclass of the point. Since the behaviour of the move method is exactly the same it will be a static method and since the draw method changes its behaviour it will have to be a dynamic method.   Point - Public Interface  The structure for static part is exactly the same as the cat example:  #ifndef POINT_H_ #define POINT_H_  #include &lt;ooc.h&gt;  /*------------------------------------------------*/ /*----------- ClassVar declaration ---------------*/ /*------------------------------------------------*/ CLASS_DECLARATION(Point);  static inline o_Point Point(int x, int y){     return ooc_new(PointClass(), x, y); }  void Point_move(o_Point _self, int delta_x, int delta_y);   #endif   To be able to have dynamically linked methods we must have another type of object, the Metaclass. The metaclass stores a reference to the methods a class can call.  The base metaclass is the class, and all metaclasses must subclass it.   To create a metaclass for the Point just create a class with the name PointClass  CLASS_DECLARATION(PointClass);   There should be no constructor for the metaclass!   To declare a dynamic method you must create a function descriptor for that method.   Function descriptors  Function descriptors are use to define a function in one single place, and be able to reuse this declaration across the program.   The function descriptor is composed of 3 macros and must obey the following rules:     The name must be all caps and start with M_   The name must reflect the function the descriptor describes   The three macros must start with the names of the descriptor   The three macros are the definition macro, the argument list macro and the parameter list macro   Ex: For a function descriptor called M_COMPARABLE_COMPARE_TO that describes the function:  int Comparable_compareTo(const void* _self, void* _destroyable_other)     We have the definition macro that has the return type of the function followed by the function name      #define M_COMPARABLE_COMPARE_TO_DEF int, Comparable_compareTo           We have the argument list macro which describes the arguments the function takes     #define M_COMPARABLE_COMPARE_TO_ARG   const void* _self, void* _destroyable_other           And the parameter list which is the M_COMPARABLE_COMPARE_TO_ARG without the types     #define M_COMPARABLE_COMPARE_TO_PARAM  _self, _destroyable_other           So if we want to represent the dynamically linked method  void Point_draw(o_Point _self);  we must create the M_POINT_DRAW descriptor  #define M_POINT_DRAW_DEF   void, Point_draw #define M_POINT_DRAW_ARG   o_Point _self #define M_POINT_DRAW_PARAM         _self DYNAMIC_METHOD_HEADER(M_POINT_DRAW);   With that the public interface is done  // File: point.h #ifndef POINT_H_ #define POINT_H_  #include &lt;ooc.h&gt;  /*------------------------------------------------*/ /*----------- ClassVar declaration ---------------*/ /*------------------------------------------------*/ CLASS_DECLARATION(Point); CLASS_DECLARATION(PointClass);  static inline o_Point Point(int x, int y){     return ooc_new(PointClass(), x, y); }  void Point_move(o_Point _self, int delta_x, int delta_y);   #define M_POINT_DRAW_DEF   void, Point_draw #define M_POINT_DRAW_ARG   o_Point _self #define M_POINT_DRAW_PARAM         _self DYNAMIC_METHOD_HEADER(M_POINT_DRAW);  #endif   Point - Reserved Interface   The Point class representation follows exactly the same structure as the Cat class example.   #include &lt;point.h&gt; #include &lt;ooc.r&gt;  typedef struct Point_r{     const Object_r _;     int x;     int y; }Point_r;   But we must also implement the metaclass PointClass_r representation, it must be a subclass of Class and must have a pointer of the type of our dynamic function.   typedef struct PointClass_r{     const Class_r _; // The superclass is Class, because this is a metaclass     CLASS_DYNAMIC_METHOD(M_POINT_DRAW); }PointClass_r;  SUPER_DYNAMIC_METHOD(M_POINT_DRAW);   The CLASS_DYNAMIC_METHOD(M_POINT_DRAW) will create a pointer to a function of the type of function the function descriptor describes.   The SUPER_DYNAMIC_METHOD(M_POINT_DRAW) will create the super function that allows subclasses to call its superclass version of the function.   The finished restricted interface will look like this   #ifndef POINT_R_ #define POINT_R_  #include &lt;point.h&gt; #include &lt;ooc.r&gt;  typedef struct Point_r{     const Object_r _;     int x;     int y; }Point_r;  typedef struct PointClass_r{     const Class_r _;     CLASS_DYNAMIC_METHOD(M_POINT_DRAW); }PointClass_r;  SUPER_DYNAMIC_METHOD(M_POINT_DRAW);  #endif   Point - Implementation file   If our class had only the move method the implementation file would look like this   #include &lt;point.h&gt; #include &lt;point.r&gt; #include &lt;lua_assert.h&gt;  void Point_move(o_Point _self, int delta_x, int delta_y){     CAST(self, Point);     ASSERT(self,);     self-&gt;x += delta_x;     self-&gt;y += delta_y; }  static OVERWRITE_METHOD(Point, M_CTOR){     SUPER_CTOR(self, Point);     ASSERT(self, NULL);     self-&gt;x = CTOR_GET_PARAM(int);     self-&gt;y = CTOR_GET_PARAM(int);     return self; }  const void* Point_d; const void* initPoint(){     return ooc_new( ClassClass(), // Metaclass             \"Point\",              //Name             ObjectClass(),        // Superclass             sizeof(Point_r),      // Size of description             LINK_METHOD(Point, M_CTOR), // Linking the dynamic methods             0); }   But in order to add the dynamically linked method we have to do a couple of extra steps.   First we have to implement the dynamic linkage, to do that we use the DYNAMIC_METHOD(metaclass__, error_return_, func_desc_) macro.   DYNAMIC_METHOD(PointClass, , M_POINT_DRAW);   The middle parameter is what to return when there is a linkage error, since Point_draw doesn’t return anything, we leave it empty.   Now that the dynamic linkage is up and running we have to create the constructor for our metaclass, this way we will be able to tell our class which function we should point to:   static OVERWRITE_METHOD(PointClass, M_CTOR){     SUPER_CTOR(self, PointClass);     SELECTOR_LOOP(         FIRST_SELECTOR(M_POINT_DRAW)     ) }  The metaclass constructor will always look like this. If you have more than one dynamic linked method you also, for example a method described by, M_POINT_UNDRAW you would use the ADD_SELECTOR(M_POINT_UNDRAW) after that. e.g,  static OVERWRITE_METHOD(PointClass, M_CTOR){     SUPER_CTOR(self, PointClass);     SELECTOR_LOOP(         FIRST_SELECTOR(M_POINT_DRAW)         ADD_SELECTOR(M_POINT_UNDRAW)     ) }   We must also create the metaclass descriptor and initializer  const void* PointClass_d; const void* initPointClass(){     return ooc_new( ClassClass(),             \"PointClass\",             ClassClass(),             sizeof(PointClass_r),             LINK_METHOD(PointClass, M_CTOR),             0); }   Now the M_POINT_DRAW is dynamically linked just like M_CTOR, so we will have to overwrite it and link it in the initPoint() method, and also change the point metaclass to be PointClass   static OVERWRITE_METHOD(Point, M_POINT_DRAW){     CAST(self, Point);     ASSERT(self, );     printf(\"Point at %d, %d\\n\", self-&gt;x, self-&gt;y); }  const void* initPoint(){     return ooc_new( PointClassClass(), // New Metaclass             \"Point\",                         ObjectClass(),             sizeof(Point_r),             LINK_METHOD(Point, M_CTOR),             LINK_METHOD(Point, M_POINT_DRAW), // Linking M_POINT_DRAW             0); }   Our complete implementation file should look similar to this:   // File: point.c #include &lt;point.h&gt; #include &lt;point.r&gt; #include &lt;lua_assert.h&gt;  DYNAMIC_METHOD(PointClass, , M_POINT_DRAW);  void Point_move(o_Point _self, int delta_x, int delta_y){     CAST(self, Point);     ASSERT(self,);     self-&gt;x += delta_x;     self-&gt;y += delta_y; }  static OVERWRITE_METHOD(Point, M_POINT_DRAW){     CAST(self, Point);     ASSERT(self, );     printf(\"Point at %d, %d\\n\", self-&gt;x, self-&gt;y); }  static OVERWRITE_METHOD(Point, M_CTOR){     SUPER_CTOR(self, Point);     ASSERT(self, NULL);     self-&gt;x = CTOR_GET_PARAM(int);     self-&gt;y = CTOR_GET_PARAM(int);     return self; }  static OVERWRITE_METHOD(PointClass, M_CTOR){     SUPER_CTOR(self, PointClass);     SELECTOR_LOOP(         FIRST_SELECTOR(M_POINT_DRAW)     ) }  const void* Point_d; const void* PointClass_d; const void* initPoint(){     return ooc_new(\tPointClassClass(),             \"Point\",             ObjectClass(),             sizeof(Point_r),             LINK_METHOD(Point, M_CTOR),             LINK_METHOD(Point, M_POINT_DRAW),             0); } const void* initPointClass(){     return ooc_new(\tClassClass(),             \"PointClass\",             ClassClass(),             sizeof(PointClass_r),             LINK_METHOD(PointClass, M_CTOR),             0); }  Quick test ———- Now if you include the “point.h” public interface and run the following program      o_Point o_point = Point(3,5);     Point_draw(o_point);     Point_move(o_point, 10, 10);     Point_draw(o_point);     Point_move(o_point, -15, -20);     Point_draw(o_point);     OOC_DELETE(o_point);   you should see this as an output  Point at 3, 5 Point at 13, 15 Point at -2, -5   Now we can proceed to the creation of the circle   Circle - Public Interface  The circle public interface is pretty simple, since it inherits all methods from point we don’t have to declare any method. Only the class and its constructor.   // File: circle.h #ifndef CIRCLE_H__ #define CIRCLE_H__  #include \"point.h\"  CLASS_DECLARATION(Circle);  static inline o_Circle Circle(int x, int y, int radius){     return ooc_new(CircleClass(), x, y, radius); }  #endif //CIRCLE_H__  Circle - Reserved Interface ————————-   The reserved interface is also pretty straightforward. You have to set the point as the superclass and add the radius field.   // File: circle.r #ifndef CIRCLE_R__ #define CIRCLE_R__  #include \"circle.h\" #include \"point.r\"  typedef struct Circle_r{     const Point_r _; //Superclass is Point not Object     int radius; }Circle_r;  #endif //CIRCLE_R__   We don’t have to declare the x and y variables because they already exist inside the Point_r struct.   Circle implementation  The implementation is also simple we just overwrite the draw and constructor and initialize the descriptor   // File: circle.c #include \"circle.h\" #include \"circle.r\" #include \"lua_assert.h\"  static OVERWRITE_METHOD(Circle, M_POINT_DRAW){     CAST(self, Circle);     ASSERT(self, );     printf(\"Circle with radius %d at %d, %d\\n\", self-&gt;radius, self-&gt;_.x, self-&gt;_.y); }  static OVERWRITE_METHOD(Circle, M_CTOR){     SUPER_CTOR(self, Circle);     ASSERT(self, NULL);     self-&gt;radius = CTOR_GET_PARAM(int);     return self; }  const void* Circle_d; const void* initCircle(){     return ooc_new(PointClassClass(),             \"Circle\",             PointClass(),             sizeof(Circle_r),             LINK_METHOD(Circle, M_CTOR),             LINK_METHOD(Circle, M_POINT_DRAW),             0); }  Analysing the parts we have some noteworthy sections:   In the draw overwriting we have this part:  printf(\"Circle with radius %d at %d, %d\\n\", self-&gt;radius, self-&gt;_.x, self-&gt;_.y);  To access the  superclass attributes we have to access it through the superclass struct. Another way to do this is to cast the pointer and access it directly  ((Point_r*)self)-&gt;x   In the constructor we don’t need to initialize the arguments of the Point_r struct because the SUPER_CTOR(self, Circle); will do that for us. So any calls to CTOR_GET_PARAM here will get the next parameters after the point parameters.   And that’s it. Now we can run the following program, after including “circle.h”:       o_Point o_point = Point(3,5);     o_Circle o_circle = Circle(4,3, 10);     Point_draw(o_point);     Point_move(o_point, 10, 10);     Point_draw(o_point);     Point_move(o_point, -15, -20);     Point_draw(o_point);     Point_draw(o_circle);     Point_move(o_circle, 7, 2);     Point_draw(o_circle);     Point_move(o_circle, -3, 30);     Point_draw(o_circle);     OOC_DELETE(o_point);     OOC_DELETE(o_circle);   and the output will be  Point at 3, 5 Point at 13, 15 Point at -2, -5 Circle with radius 10 at 4, 3 Circle with radius 10 at 11, 5 Circle with radius 10 at 8, 35  ","categories": ["OOC"],
        "tags": ["c","OOC","Classe"],
        "url": "https://rodrigowerberich.github.io//ooc/super-class/br",
        "teaser":null},{
        "title": "OOC - Interface",
        "excerpt":"Interface creation   Sometimes we want something more general than a base class, we wan’t to be able to specify that we want a specific behaviour, but without defining a base behaviour. Or maybe we wan’t an specific behaviour, but not all the other things that comes with the super class, and we wan’t to be able to combine these behaviours without creating super complex inheritance trees. For that we have interfaces.   Interfaces are nothing more than a blueprint the class must follow. To understand more about this, we will implement the Printable interface. It consists of two methods, the Printable_printToFile and the Printable_print (which prints to the stdout).   An interface is composed of two files, its public interface (.h) and the implementation (.c).   Public interface  Let’s begin with the one Printable_printToFile blueprint. To do that we must create the function descriptor for our desired signature.  // Desired signature int Printable_printToFile(void* _self, FILE* fp);   Our descriptor will be called M_PRINTABLE_PRINT_TO_FILE, and it will be:   // Function descriptor for int Printable_printToFile(void* _self, FILE* fp); #define M_PRINTABLE_PRINT_TO_FILE_DEF int, Printable_printToFile #define M_PRINTABLE_PRINT_TO_FILE_ARG const void* _self, FILE* fp #define M_PRINTABLE_PRINT_TO_FILE_PARAM           _self,       fp   To declare that our interface exists we just have to call the INTERFACE_METHOD_DECLARATION(func_desc_) macro.   The Printable_print function can make use of the ``Printable_printToFile, just passing the stdout` as the output file.   static inline int Printable_print(const void* _self){     return Printable_printToFile(_self, stdout); }   With that our interfaces public interface is complete  // File: printable_interface.h #ifndef PRINTABLE_INTERFACE_H__ #define PRINTABLE_INTERFACE_H__  #include &lt;ooc.h&gt; #include &lt;stdio.h&gt;  /*------------------------------------------------*/ /*----- Interface methods declaration ------------*/ /*------------------------------------------------*/  // This method should print an object string representation // into the file descriptor passed into it. // It must return the number of bytes written if succesful, if an error // occurs it should return a negative value // Function descriptor for int Printable_printToFile(void* _self, FILE* fp); #define M_PRINTABLE_PRINT_TO_FILE_DEF int, Printable_printToFile #define M_PRINTABLE_PRINT_TO_FILE_ARG const void* _self, FILE* fp #define M_PRINTABLE_PRINT_TO_FILE_PARAM           _self,       fp INTERFACE_METHOD_DECLARATION(M_PRINTABLE_PRINT_TO_FILE);  //Shortcut for printing an object into the standart output. static inline int Printable_print(const void* _self){     return Printable_printToFile(_self, stdout); }  #endif //PRINTABLE_INTERFACE_H__   Interface implementation   To implement the interface you just have to use the INTERFACE_METHOD_IMPLEMENTATION(error_return_value_, func_desc_) macro. Its arguments are the value to return if the interface is called on something that doesn’t accept it and the function descriptor for that interface.   The final interface implementation is as follows  // File: printable_interface.c #include &lt;printable_interface.h&gt;  /*------------------------------------------------*/ /*----- Interface methods implementation ---------*/ /*------------------------------------------------*/ INTERFACE_METHOD_IMPLEMENTATION(-1, M_PRINTABLE_PRINT_TO_FILE);   Now to test this interface we will add it into the Point class we created earlier.   Adding the printable interface to the Point class  In order for a class to be able to implement an interface, it must have a metaclass. The interface methods are also overwritable by the base class subclasses.   To incorporate the interface into the class we will have to modify the tree files (public and reserved interfaces and the implementation).   Since Point already has the metaclass PointClass all we to do in the public interface is #include the printable interface and use the INTERFACE_METHOD_HEADER(metaclass_, func_desc_)macro.   INTERFACE_METHOD_HEADER(PointClass, M_PRINTABLE_PRINT_TO_FILE);   In the reserved interface we will have to add the interface to the metaclass representation and add the super method of the interface   typedef struct PointClass_r{     const Class_r _;     CLASS_DYNAMIC_METHOD(M_POINT_DRAW);     CLASS_INTERFACE_METHOD(PointClass, M_PRINTABLE_PRINT_TO_FILE); }PointClass_r;  SUPER_DYNAMIC_METHOD(M_POINT_DRAW); SUPER_INTERFACE_METHOD(PointClass, M_PRINTABLE_PRINT_TO_FILE);   We do that with the CLASS_INTERFACE_METHOD and the SUPER_INTERFACE_METHOD macros, they work exactly like their dynamic methods contraparts, but they also need the metaclass name as a parameter.   To finish thing up on the implementation file we will have to create the interface method itself, add the linkage into the metaclass constructor, overwrite the interface function and link the class to overwritten method.   INTERFACE_METHOD(PointClass, -1,  M_PRINTABLE_PRINT_TO_FILE);  static OVERWRITE_METHOD(Point, M_PRINTABLE_PRINT_TO_FILE){     CAST(self, Point);     ASSERT(self, -1);     return fprintf(fp, \"(%d, %d)\\n\", self-&gt;x, self-&gt;y); }  static OVERWRITE_METHOD(PointClass, M_CTOR){     SUPER_CTOR(self, PointClass);     SELECTOR_LOOP(         FIRST_SELECTOR(M_POINT_DRAW)         ADD_INTERFACE_SELECTOR(PointClass, M_PRINTABLE_PRINT_TO_FILE)     ) }  const void* initPoint(){     return ooc_new(\tPointClassClass(),             \"Point\",             ObjectClass(),             sizeof(Point_r),             LINK_METHOD(Point, M_CTOR),             LINK_METHOD(Point, M_POINT_DRAW),             LINK_INTERFACE_METHOD(Point, PointClass, M_PRINTABLE_PRINT_TO_FILE),             0); }   All this steps are the same we did when creating a dynamically linked method, The only difference is that some of the interface macros require the metaclass as its parameter aswell.   The complete modified files are:   // File: point.h #ifndef POINT_H_ #define POINT_H_  #include &lt;ooc.h&gt; #include &lt;printable_interface.h&gt;  /*------------------------------------------------*/ /*----------- ClassVar declaration ---------------*/ /*------------------------------------------------*/ CLASS_DECLARATION(Point); CLASS_DECLARATION(PointClass);  static inline o_Point Point(int x, int y){     return ooc_new(PointClass(), x, y); }  void Point_move(o_Point _self, int delta_x, int delta_y);   #define M_POINT_DRAW_DEF   void, Point_draw #define M_POINT_DRAW_ARG   o_Point _self #define M_POINT_DRAW_PARAM         _self DYNAMIC_METHOD_HEADER(M_POINT_DRAW);  INTERFACE_METHOD_HEADER(PointClass, M_PRINTABLE_PRINT_TO_FILE);  #endif   // File: point.r #ifndef POINT_R_ #define POINT_R_  #include &lt;point.h&gt; #include &lt;ooc.r&gt;  typedef struct Point_r{     const Object_r _;     int x;     int y; }Point_r;  typedef struct PointClass_r{     const Class_r _;     CLASS_DYNAMIC_METHOD(M_POINT_DRAW);     CLASS_INTERFACE_METHOD(PointClass, M_PRINTABLE_PRINT_TO_FILE); }PointClass_r;  SUPER_DYNAMIC_METHOD(M_POINT_DRAW); SUPER_INTERFACE_METHOD(PointClass, M_PRINTABLE_PRINT_TO_FILE);  #endif   // File: point.c #include &lt;point.h&gt; #include &lt;point.r&gt; #include &lt;lua_assert.h&gt;  DYNAMIC_METHOD(PointClass, , M_POINT_DRAW); INTERFACE_METHOD(PointClass, -1,  M_PRINTABLE_PRINT_TO_FILE);  void Point_move(o_Point _self, int delta_x, int delta_y){     CAST(self, Point);     ASSERT(self,);     self-&gt;x += delta_x;     self-&gt;y += delta_y; }  static OVERWRITE_METHOD(Point, M_POINT_DRAW){     CAST(self, Point);     ASSERT(self, );     printf(\"Point at %d, %d\\n\", self-&gt;x, self-&gt;y); }  static OVERWRITE_METHOD(Point, M_PRINTABLE_PRINT_TO_FILE){     CAST(self, Point);     ASSERT(self, -1);     return fprintf(fp, \"(%d, %d)\\n\", self-&gt;x, self-&gt;y); }  static OVERWRITE_METHOD(Point, M_CTOR){     SUPER_CTOR(self, Point);     ASSERT(self, NULL);     self-&gt;x = CTOR_GET_PARAM(int);     self-&gt;y = CTOR_GET_PARAM(int);     return self; }  static OVERWRITE_METHOD(PointClass, M_CTOR){     SUPER_CTOR(self, PointClass);     SELECTOR_LOOP(         FIRST_SELECTOR(M_POINT_DRAW)         ADD_INTERFACE_SELECTOR(PointClass, M_PRINTABLE_PRINT_TO_FILE)     ) }    const void* Point_d; const void* PointClass_d; const void* initPoint(){     return ooc_new(\tPointClassClass(),             \"Point\",             ObjectClass(),             sizeof(Point_r),             LINK_METHOD(Point, M_CTOR),             LINK_METHOD(Point, M_POINT_DRAW),             LINK_INTERFACE_METHOD(Point, PointClass, M_PRINTABLE_PRINT_TO_FILE),             0); } const void* initPointClass(){     return ooc_new(\tClassClass(),             \"PointClass\",             ClassClass(),             sizeof(PointClass_r),             LINK_METHOD(PointClass, M_CTOR),             0); }   In short:                  Dynamic method       Interface                       DYNAMIC_METHOD_HEADER(func_desc_)       INTERFACE_METHOD_HEADER(metaclass_, func_desc_)                 CLASS_DYNAMIC_METHOD(func_desc_)       CLASS_INTERFACE_METHOD(metaclass_, func_desc_)                 SUPER_DYNAMIC_METHOD(func_desc_)       SUPER_INTERFACE_METHOD(metaclass_, func_desc_)                 DYNAMIC_METHOD(metaclass_, error_return_value_, func_desc_)       INTERFACE_METHOD(metaclass_, error_return_value_, func_desc_)                 OVERWRITE_METHOD(class_, func_desc_)       OVERWRITE_METHOD(class_, func_desc_)                 FIRST_SELECTOR(func_desc_)       FIRST_INTERFACE_SELECTOR(metaclass_, func_desc_)                 ADD_SELECTOR(func_desc_)       ADD_INTERFACE_SELECTOR(metaclass_, func_desc_)                 LINK_METHOD(class_, func_desc_)       LINK_INTERFACE_METHOD(class_, metaclass_, func_desc_)           All done, we can now use the printable interface in Point objects and all its subclasses.   If we run:      o_Point o_point = Point(3,5);     o_Circle o_circle = Circle(4,3, 10);     Point_draw(o_point);     Point_move(o_point, 10, 10);     Point_draw(o_point);     Point_move(o_point, -15, -20);     Point_draw(o_point);     Point_draw(o_circle);     Point_move(o_circle, 7, 2);     Point_draw(o_circle);     Point_move(o_circle, -3, 30);     Point_draw(o_circle);     Printable_print(o_point);     Printable_print(o_circle);     OOC_DELETE(o_point);     OOC_DELETE(o_circle);  The output will be  Point at 3, 5 Point at 13, 15 Point at -2, -5 Circle with radius 10 at 4, 3 Circle with radius 10 at 11, 5 Circle with radius 10 at 8, 35 (-2, -5) (8, 35)   Overwriting the interface behaviour in Circle   As we can see the circle and point calls to Printable_print returned the same thing. That’s because when a subclass does not overwrite the base class method, it will default to the base class behaviour.   If we want to change that behaviour we just have to overwrite the behaviour in the circle implementation.   Just add   static OVERWRITE_METHOD(Circle, M_PRINTABLE_PRINT_TO_FILE){     CAST(self, Circle);     ASSERT(self, -1);     return fprintf(fp, \"(%d, %d)r:%d\\n\", ((Point_r*)self)-&gt;x, ((Point_r*)self)-&gt;y, self-&gt;radius); }   and link the new interface method   const void* initCircle(){     return ooc_new(\tPointClassClass(),             \"Circle\",             PointClass(),             sizeof(Circle_r),             LINK_METHOD(Circle, M_CTOR),             LINK_METHOD(Circle, M_POINT_DRAW),             LINK_INTERFACE_METHOD(Circle, PointClass, M_PRINTABLE_PRINT_TO_FILE),             0); }   The complete file will look like this:  // File: circle.c #include \"circle.h\" #include \"circle.r\" #include \"lua_assert.h\"  static OVERWRITE_METHOD(Circle, M_POINT_DRAW){     CAST(self, Circle);     ASSERT(self, );     printf(\"Circle with radius %d at %d, %d\\n\", self-&gt;radius, self-&gt;_.x, self-&gt;_.y); }  static OVERWRITE_METHOD(Circle, M_PRINTABLE_PRINT_TO_FILE){     CAST(self, Circle);     ASSERT(self, -1);     return fprintf(fp, \"(%d, %d)r:%d\\n\", ((Point_r*)self)-&gt;x, ((Point_r*)self)-&gt;y, self-&gt;radius); }  static OVERWRITE_METHOD(Circle, M_CTOR){     SUPER_CTOR(self, Circle);     ASSERT(self, NULL);     self-&gt;radius = CTOR_GET_PARAM(int);     return self; }  const void* Circle_d; const void* initCircle(){     return ooc_new(\tPointClassClass(),             \"Circle\",             PointClass(),             sizeof(Circle_r),             LINK_METHOD(Circle, M_CTOR),             LINK_METHOD(Circle, M_POINT_DRAW),             LINK_INTERFACE_METHOD(Circle, PointClass, M_PRINTABLE_PRINT_TO_FILE),             0); }   The output of that same program will now be   Point at 3, 5 Point at 13, 15 Point at -2, -5 Circle with radius 10 at 4, 3 Circle with radius 10 at 11, 5 Circle with radius 10 at 8, 35 (-2, -5) (8, 35)r:10  ","categories": ["OOC"],
        "tags": ["c","OOC","Interface"],
        "url": "https://rodrigowerberich.github.io//ooc/interface/br",
        "teaser":null},{
        "title": "OOC - Base",
        "excerpt":"How to use it?   There are many ways to achieve object orientation in C. We will follow the approach used by Axel-Tobias Schreiner in his Object-Oriented Programming With ANSI-C book. In it we use hidden structs, void pointers, variatic functions and dynamic linkage to achieve object orientation.   One of the main differences of our method is that we will not be using a different preprocessor for our development. We will use the C preprocessor and MACROS to facilitate our development.   It’s really simple to starting using it, you just have to get the code for the base classes, the macros and some simple classes and interfaces and include what you will really use.   #include \"vector.h\" int main(){     o_Vector o_int_vector = VectorC(int);     Collection_inplaceAddAllC(o_string_vector, int, ARG({1, 2, 3, 4}));     o_Iterator o_iterator = Iterable_create(o_int_vector);     Collection_add(INT(5));     Collection_add(INT(6));     for_iterator(o_iterator){         int* p_int = Iterator_currItem(o_iterator);         if(p_int){             printf(\"%d,\", *p_int); // Will print out 1,2,3,4,5,6,         }     }     printf(\"\\n\");     OOC_DELETE(o_iterator);     OOC_DELETE(o_int_vector); }  ","categories": ["OOC"],
        "tags": ["c","OOC"],
        "url": "https://rodrigowerberich.github.io//ooc/base/en",
        "teaser":null},{
        "title": "OOC - Simple Class",
        "excerpt":"Creating a simple class   Let’s start by creating a simple class: the cat. A cat can be really simplified and be represented by a color, a weight, a length and a name. These will be our attributes.   A cat can “talk”, jump and eat, amongst other things. These will be our methods, or interfaces. With than we can begin building our cat class.   In OOC a class is defined by three files,      the public interface or .h file,   the reserved interface or .r file and   the implementation or .c file.   Public Interface  Let’s begin with the public interface, first we must create the class itself, for that we use the CLASS_DECLARATION macro.   // File: cat.h #ifndef CAT_H_ #define CAT_H_ #include \"ooc.h\"  CLASS_DECLARATION(Cat);  #endif /* CAT_H_ */  This macro creates the type o_Cat, which we will use to refer to cat objects, the descriptor Cat_d, which is a pointer to an object that knows how to build cat objects. A forward declaration of the void* initCat(), a function that creates the Cat_d descriptor (This function must be implemented in the implementation file). And the implementation of the automatic initializer inline const void* CatClass(), which is what we will use to access the descriptor.   The next step is to create the constructors of your class, to do that we create inline functions that makes cals to the ooc_new function.  ... // File: cat.h // Empty constructor static inline o_Cat Cat(){     return ooc_new(CatClass(), 0, 0.0, 0.0, NULL); } // Complete constructor static inline o_Cat CatSpecified(int color, double weight, double length, o_String o_name){     return ooc_new(CatClass(), color, weight, length, o_name); } ...  Now we must specify what our cat can do. We do it simply be creating functions that takes as the first parameter the class object. This is will be our methods:  ... void Cat_jump(o_Cat self, double distance); void Cat_eat(o_Cat self); o_String Cat_talk(o_Cat self);  ...  With that our basic class public interface file is complete!  #ifndef CAT_H_ #define CAT_H_ #include \"ooc.h\" #include \"o_string.h\" //---- Class declaration CLASS_DECLARATION(Cat); //----  Class constructor // Empty constructor static inline o_Cat Cat(){     return ooc_new(CatClass(), 0, 0.0, 0.0, NULL); } // Complete constructor static inline o_Cat CatSpecified(int color, double weight, double length, o_String o_name){     return ooc_new(CatClass(), color, weight, length, o_name); } //---- Methods // Static methods void Cat_jump(o_Cat self, double distance); void Cat_eat(o_Cat self); o_String Cat_talk(o_Cat self); #endif /* CAT_H_ */   Reserved Interface  Now we will build the restricted interface for the cat class, this is pretty simple. All we have to do is create the cat.r file, include the ooc.r file and the public interface file and implement the struct that represents our data.   Since our cat is described by it’s color, weight, length and name we create a struct Cat_r with this information.   #ifndef CAT_R__ #define CAT_R__  #include \"ooc.r\" #include \"cat.h\"  typedef struct Cat_r{     const Object_r  _;     int             color;     double           weight;     double           length;     o_String        o_name; }Cat_r;  #endif //CAT_R__   There are two very important things to notice in this struct.     The struct must be typedef’ed to create a new type. This new type must be the class name followed by _r!   The first element of the struct must be the base class representation of this class and must be called _!   You must follow these rules or polimorphism and the macros won’t work.   Now we can start with the implementation file   Implementation file   We’ll start implementing the static linked methods Cat_jump, Cat_eat and Cat_talk.   #include \"cat.h\" #include \"cat.r\" #include \"lua_assert.h\"  void Cat_jump(o_Cat _self, double distance){     CAST(self, Cat);     ASSERT(self,);     if( (4*self-&gt;length) &lt; distance ){         printf(\"Jumping %f meters\\n\", distance);     }else{         printf(\"Can't jump that far\\n\");     } } void Cat_eat(o_Cat _self){     CAST(self, Cat);     ASSERT(self, );     self-&gt;weight += 0.01; } o_String Cat_talk(o_Cat _self){     CAST(self, Cat);     ASSERT(self, NULL);     o_String o_talk = OOC_CLONE(self-&gt;o_name);     String_appendC(o_talk, \" says meow!\");     return o_talk; }   The class methods must always have the first argument called _self and it represents the object the method is applied to. To ensure that the class methods is being applied to the right object we should always use the CAST(name_, class_) macro. This macros verifies if a variable with name “_var_name” is a subclass of the Class specified and casts it into a pointer of Class_r. If the object is not a subclass the cast will return a pointer to NULL. That is why we use to ASSERT(assertion_, return_value_) macro to check if the pointer is valid and deal with the error appropriatly.   The base object has three overwritable functions the ooc_ctor (Constructor), the ooc_dtor(Destructor) and ooc_differ(Comparison).   The only one you must alway overwrite is the constructor. If the constructor allocates any memory, you must implement the destructor and if you wan’t to change the default comparison, which compares pointers, you must overwrite the comparison.   To do that you must use the OVERWRITE_METHOD(func_desc_) macro which takes in a function descriptor (this will be explained later). The function descriptors for the constructor, destructor and difference methods are, respectively, M_CTOR, M_DTOR and M_DIFFER.   So to implement the Cat constructor  static OVERWRITE_METHOD(Cat, M_CTOR){     SUPER_CTOR(self, Cat);     ASSERT(self, NULL);     self-&gt;color = CTOR_GET_PARAM(int);     self-&gt;weight = CTOR_GET_PARAM(double);     self-&gt;length = CTOR_GET_PARAM(double);     self-&gt;o_name = CTOR_GET_PARAM(o_String);     return self; }  The SUPER_CTOR(self, Cat); will call the super class constructor. If something is wrong the variable self will be set to NULL. The macro CTOR_GET_PARAM(type_) will return the next available parameter with the type passed from the variable list. You must retrieve the parameters exactly in the order passed by the constructor.   Since o_name is an object, the cat object is now responsible for its lifespan, so we must implement the destructor to free the resource when this object is destroyed.   static OVERWRITE_METHOD(Cat, M_DTOR){     SUPER_DTOR(self, Cat);     ASSERT(self, NULL);     OOC_DELETE(self-&gt;o_name);     return self; }   The SUPER_CTOR(self, Cat); will call the super class constructor. If something is wrong the variable self will be set to NULL.   Both the constructor and the destructor should alway return self, unless something wrong occurs, then it must return NULL.   To end the class implementation all we have to do is create the description class variable Cat_d and the class initializer initCat().   const void* Cat_d; const void* initCat(){     return ooc_new(\t             ClassClass(),               // MetaClass             \"Cat\",                      // Class name             ObjectClass(),              // Super class             sizeof(Cat_r),              // Size of representation structure             LINK_METHOD(Cat, M_CTOR),   // Linking the dynamic methods             LINK_METHOD(Cat, M_DTOR),             0); // Must alway ends with a zero }   The initCat() method is called by the CatClass() automatic initializer, which will assign the object created inside initCat to the Cat_d descriptor object. This object contains the blueprint to build Cat objects.   The end implementation file should be something like this:  #include \"cat.h\" #include \"cat.r\" #include \"lua_assert.h\"  // Static methods ------ void Cat_jump(o_Cat _self, double distance){     CAST(self, Cat);     ASSERT(self,);     if( (4*self-&gt;length) &lt; distance ){         printf(\"Jumping %f meters\\n\", distance);     }else{         printf(\"Can't jump that far\\n\");     } } void Cat_eat(o_Cat _self){     CAST(self, Cat);     ASSERT(self, );     self-&gt;weight += 0.01; } o_String Cat_talk(o_Cat _self){     CAST(self, Cat);     ASSERT(self, NULL);     o_String o_talk = OOC_CLONE(self-&gt;o_name);     String_appendC(o_talk, \" says meow!\");     return o_talk; }  // Dynamic methods ----------- // Overwriting object ----------- static OVERWRITE_METHOD(Cat, M_CTOR){     SUPER_CTOR(self, Cat);     ASSERT(self, NULL);     self-&gt;color = CTOR_GET_PARAM(int);     self-&gt;weight = CTOR_GET_PARAM(double);     self-&gt;length = CTOR_GET_PARAM(double);     self-&gt;o_name = CTOR_GET_PARAM(o_String);     return self; }  static OVERWRITE_METHOD(Cat, M_DTOR){     SUPER_DTOR(self, Cat);     ASSERT(self, NULL);     OOC_DELETE(self-&gt;o_name);     return self; }  // Descriptor and initializer const void* Cat_d; const void* initCat(){     return ooc_new(\t             ClassClass(),               // MetaClass             \"Cat\",                      // Class name             ObjectClass(),              // Super class             sizeof(Cat_r),              // Size of representation structure             LINK_METHOD(Cat, M_CTOR),   // Linking the dynamic methods             LINK_METHOD(Cat, M_DTOR),             0); // Must alway ends with a zero }   ","categories": ["OOC"],
        "tags": ["c","OOC","Classe"],
        "url": "https://rodrigowerberich.github.io//ooc/simple-class/en",
        "teaser":null},{
        "title": "OOC - Super Class",
        "excerpt":"Creating a super class  For this example we will create two classes, the Point and the Circle. The point has two atributtes, it’s x and y coordinates. And two methods, the move and draw methods.   To move the point we will only add the delta x, and delta y to the currents point position. To draw it we will only print “Point at x, y”   The circle follows the same principle, but it also has a radius. The move method does exactly the same, but the draw method must print “Circle with radius r at x,y” instead.   To do that we will implement the circle as a subclass of the point. Since the behaviour of the move method is exactly the same it will be a static method and since the draw method changes its behaviour it will have to be a dynamic method.   Point - Public Interface  The structure for static part is exactly the same as the cat example:  #ifndef POINT_H_ #define POINT_H_  #include &lt;ooc.h&gt;  /*------------------------------------------------*/ /*----------- ClassVar declaration ---------------*/ /*------------------------------------------------*/ CLASS_DECLARATION(Point);  static inline o_Point Point(int x, int y){     return ooc_new(PointClass(), x, y); }  void Point_move(o_Point _self, int delta_x, int delta_y);   #endif   To be able to have dynamically linked methods we must have another type of object, the Metaclass. The metaclass stores a reference to the methods a class can call.  The base metaclass is the class, and all metaclasses must subclass it.   To create a metaclass for the Point just create a class with the name PointClass  CLASS_DECLARATION(PointClass);   There should be no constructor for the metaclass!   To declare a dynamic method you must create a function descriptor for that method.   Function descriptors  Function descriptors are use to define a function in one single place, and be able to reuse this declaration across the program.   The function descriptor is composed of 3 macros and must obey the following rules:     The name must be all caps and start with M_   The name must reflect the function the descriptor describes   The three macros must start with the names of the descriptor   The three macros are the definition macro, the argument list macro and the parameter list macro   Ex: For a function descriptor called M_COMPARABLE_COMPARE_TO that describes the function:  int Comparable_compareTo(const void* _self, void* _destroyable_other)     We have the definition macro that has the return type of the function followed by the function name      #define M_COMPARABLE_COMPARE_TO_DEF int, Comparable_compareTo           We have the argument list macro which describes the arguments the function takes     #define M_COMPARABLE_COMPARE_TO_ARG   const void* _self, void* _destroyable_other           And the parameter list which is the M_COMPARABLE_COMPARE_TO_ARG without the types     #define M_COMPARABLE_COMPARE_TO_PARAM  _self, _destroyable_other           So if we want to represent the dynamically linked method  void Point_draw(o_Point _self);  we must create the M_POINT_DRAW descriptor  #define M_POINT_DRAW_DEF   void, Point_draw #define M_POINT_DRAW_ARG   o_Point _self #define M_POINT_DRAW_PARAM         _self DYNAMIC_METHOD_HEADER(M_POINT_DRAW);   With that the public interface is done  // File: point.h #ifndef POINT_H_ #define POINT_H_  #include &lt;ooc.h&gt;  /*------------------------------------------------*/ /*----------- ClassVar declaration ---------------*/ /*------------------------------------------------*/ CLASS_DECLARATION(Point); CLASS_DECLARATION(PointClass);  static inline o_Point Point(int x, int y){     return ooc_new(PointClass(), x, y); }  void Point_move(o_Point _self, int delta_x, int delta_y);   #define M_POINT_DRAW_DEF   void, Point_draw #define M_POINT_DRAW_ARG   o_Point _self #define M_POINT_DRAW_PARAM         _self DYNAMIC_METHOD_HEADER(M_POINT_DRAW);  #endif   Point - Reserved Interface   The Point class representation follows exactly the same structure as the Cat class example.   #include &lt;point.h&gt; #include &lt;ooc.r&gt;  typedef struct Point_r{     const Object_r _;     int x;     int y; }Point_r;   But we must also implement the metaclass PointClass_r representation, it must be a subclass of Class and must have a pointer of the type of our dynamic function.   typedef struct PointClass_r{     const Class_r _; // The superclass is Class, because this is a metaclass     CLASS_DYNAMIC_METHOD(M_POINT_DRAW); }PointClass_r;  SUPER_DYNAMIC_METHOD(M_POINT_DRAW);   The CLASS_DYNAMIC_METHOD(M_POINT_DRAW) will create a pointer to a function of the type of function the function descriptor describes.   The SUPER_DYNAMIC_METHOD(M_POINT_DRAW) will create the super function that allows subclasses to call its superclass version of the function.   The finished restricted interface will look like this   #ifndef POINT_R_ #define POINT_R_  #include &lt;point.h&gt; #include &lt;ooc.r&gt;  typedef struct Point_r{     const Object_r _;     int x;     int y; }Point_r;  typedef struct PointClass_r{     const Class_r _;     CLASS_DYNAMIC_METHOD(M_POINT_DRAW); }PointClass_r;  SUPER_DYNAMIC_METHOD(M_POINT_DRAW);  #endif   Point - Implementation file   If our class had only the move method the implementation file would look like this   #include &lt;point.h&gt; #include &lt;point.r&gt; #include &lt;lua_assert.h&gt;  void Point_move(o_Point _self, int delta_x, int delta_y){     CAST(self, Point);     ASSERT(self,);     self-&gt;x += delta_x;     self-&gt;y += delta_y; }  static OVERWRITE_METHOD(Point, M_CTOR){     SUPER_CTOR(self, Point);     ASSERT(self, NULL);     self-&gt;x = CTOR_GET_PARAM(int);     self-&gt;y = CTOR_GET_PARAM(int);     return self; }  const void* Point_d; const void* initPoint(){     return ooc_new( ClassClass(), // Metaclass             \"Point\",              //Name             ObjectClass(),        // Superclass             sizeof(Point_r),      // Size of description             LINK_METHOD(Point, M_CTOR), // Linking the dynamic methods             0); }   But in order to add the dynamically linked method we have to do a couple of extra steps.   First we have to implement the dynamic linkage, to do that we use the DYNAMIC_METHOD(metaclass__, error_return_, func_desc_) macro.   DYNAMIC_METHOD(PointClass, , M_POINT_DRAW);   The middle parameter is what to return when there is a linkage error, since Point_draw doesn’t return anything, we leave it empty.   Now that the dynamic linkage is up and running we have to create the constructor for our metaclass, this way we will be able to tell our class which function we should point to:   static OVERWRITE_METHOD(PointClass, M_CTOR){     SUPER_CTOR(self, PointClass);     SELECTOR_LOOP(         FIRST_SELECTOR(M_POINT_DRAW)     ) }  The metaclass constructor will always look like this. If you have more than one dynamic linked method you also, for example a method described by, M_POINT_UNDRAW you would use the ADD_SELECTOR(M_POINT_UNDRAW) after that. e.g,  static OVERWRITE_METHOD(PointClass, M_CTOR){     SUPER_CTOR(self, PointClass);     SELECTOR_LOOP(         FIRST_SELECTOR(M_POINT_DRAW)         ADD_SELECTOR(M_POINT_UNDRAW)     ) }   We must also create the metaclass descriptor and initializer  const void* PointClass_d; const void* initPointClass(){     return ooc_new( ClassClass(),             \"PointClass\",             ClassClass(),             sizeof(PointClass_r),             LINK_METHOD(PointClass, M_CTOR),             0); }   Now the M_POINT_DRAW is dynamically linked just like M_CTOR, so we will have to overwrite it and link it in the initPoint() method, and also change the point metaclass to be PointClass   static OVERWRITE_METHOD(Point, M_POINT_DRAW){     CAST(self, Point);     ASSERT(self, );     printf(\"Point at %d, %d\\n\", self-&gt;x, self-&gt;y); }  const void* initPoint(){     return ooc_new( PointClassClass(), // New Metaclass             \"Point\",                         ObjectClass(),             sizeof(Point_r),             LINK_METHOD(Point, M_CTOR),             LINK_METHOD(Point, M_POINT_DRAW), // Linking M_POINT_DRAW             0); }   Our complete implementation file should look similar to this:   // File: point.c #include &lt;point.h&gt; #include &lt;point.r&gt; #include &lt;lua_assert.h&gt;  DYNAMIC_METHOD(PointClass, , M_POINT_DRAW);  void Point_move(o_Point _self, int delta_x, int delta_y){     CAST(self, Point);     ASSERT(self,);     self-&gt;x += delta_x;     self-&gt;y += delta_y; }  static OVERWRITE_METHOD(Point, M_POINT_DRAW){     CAST(self, Point);     ASSERT(self, );     printf(\"Point at %d, %d\\n\", self-&gt;x, self-&gt;y); }  static OVERWRITE_METHOD(Point, M_CTOR){     SUPER_CTOR(self, Point);     ASSERT(self, NULL);     self-&gt;x = CTOR_GET_PARAM(int);     self-&gt;y = CTOR_GET_PARAM(int);     return self; }  static OVERWRITE_METHOD(PointClass, M_CTOR){     SUPER_CTOR(self, PointClass);     SELECTOR_LOOP(         FIRST_SELECTOR(M_POINT_DRAW)     ) }  const void* Point_d; const void* PointClass_d; const void* initPoint(){     return ooc_new(\tPointClassClass(),             \"Point\",             ObjectClass(),             sizeof(Point_r),             LINK_METHOD(Point, M_CTOR),             LINK_METHOD(Point, M_POINT_DRAW),             0); } const void* initPointClass(){     return ooc_new(\tClassClass(),             \"PointClass\",             ClassClass(),             sizeof(PointClass_r),             LINK_METHOD(PointClass, M_CTOR),             0); }  Quick test ———- Now if you include the “point.h” public interface and run the following program      o_Point o_point = Point(3,5);     Point_draw(o_point);     Point_move(o_point, 10, 10);     Point_draw(o_point);     Point_move(o_point, -15, -20);     Point_draw(o_point);     OOC_DELETE(o_point);   you should see this as an output  Point at 3, 5 Point at 13, 15 Point at -2, -5   Now we can proceed to the creation of the circle   Circle - Public Interface  The circle public interface is pretty simple, since it inherits all methods from point we don’t have to declare any method. Only the class and its constructor.   // File: circle.h #ifndef CIRCLE_H__ #define CIRCLE_H__  #include \"point.h\"  CLASS_DECLARATION(Circle);  static inline o_Circle Circle(int x, int y, int radius){     return ooc_new(CircleClass(), x, y, radius); }  #endif //CIRCLE_H__  Circle - Reserved Interface ————————-   The reserved interface is also pretty straightforward. You have to set the point as the superclass and add the radius field.   // File: circle.r #ifndef CIRCLE_R__ #define CIRCLE_R__  #include \"circle.h\" #include \"point.r\"  typedef struct Circle_r{     const Point_r _; //Superclass is Point not Object     int radius; }Circle_r;  #endif //CIRCLE_R__   We don’t have to declare the x and y variables because they already exist inside the Point_r struct.   Circle implementation  The implementation is also simple we just overwrite the draw and constructor and initialize the descriptor   // File: circle.c #include \"circle.h\" #include \"circle.r\" #include \"lua_assert.h\"  static OVERWRITE_METHOD(Circle, M_POINT_DRAW){     CAST(self, Circle);     ASSERT(self, );     printf(\"Circle with radius %d at %d, %d\\n\", self-&gt;radius, self-&gt;_.x, self-&gt;_.y); }  static OVERWRITE_METHOD(Circle, M_CTOR){     SUPER_CTOR(self, Circle);     ASSERT(self, NULL);     self-&gt;radius = CTOR_GET_PARAM(int);     return self; }  const void* Circle_d; const void* initCircle(){     return ooc_new(PointClassClass(),             \"Circle\",             PointClass(),             sizeof(Circle_r),             LINK_METHOD(Circle, M_CTOR),             LINK_METHOD(Circle, M_POINT_DRAW),             0); }  Analysing the parts we have some noteworthy sections:   In the draw overwriting we have this part:  printf(\"Circle with radius %d at %d, %d\\n\", self-&gt;radius, self-&gt;_.x, self-&gt;_.y);  To access the  superclass attributes we have to access it through the superclass struct. Another way to do this is to cast the pointer and access it directly  ((Point_r*)self)-&gt;x   In the constructor we don’t need to initialize the arguments of the Point_r struct because the SUPER_CTOR(self, Circle); will do that for us. So any calls to CTOR_GET_PARAM here will get the next parameters after the point parameters.   And that’s it. Now we can run the following program, after including “circle.h”:       o_Point o_point = Point(3,5);     o_Circle o_circle = Circle(4,3, 10);     Point_draw(o_point);     Point_move(o_point, 10, 10);     Point_draw(o_point);     Point_move(o_point, -15, -20);     Point_draw(o_point);     Point_draw(o_circle);     Point_move(o_circle, 7, 2);     Point_draw(o_circle);     Point_move(o_circle, -3, 30);     Point_draw(o_circle);     OOC_DELETE(o_point);     OOC_DELETE(o_circle);   and the output will be  Point at 3, 5 Point at 13, 15 Point at -2, -5 Circle with radius 10 at 4, 3 Circle with radius 10 at 11, 5 Circle with radius 10 at 8, 35  ","categories": ["OOC"],
        "tags": ["c","OOC","Classe"],
        "url": "https://rodrigowerberich.github.io//ooc/super-class/en",
        "teaser":null},{
        "title": "OOC - Interface",
        "excerpt":"Interface creation   Sometimes we want something more general than a base class, we wan’t to be able to specify that we want a specific behaviour, but without defining a base behaviour. Or maybe we wan’t an specific behaviour, but not all the other things that comes with the super class, and we wan’t to be able to combine these behaviours without creating super complex inheritance trees. For that we have interfaces.   Interfaces are nothing more than a blueprint the class must follow. To understand more about this, we will implement the Printable interface. It consists of two methods, the Printable_printToFile and the Printable_print (which prints to the stdout).   An interface is composed of two files, its public interface (.h) and the implementation (.c).   Public interface  Let’s begin with the one Printable_printToFile blueprint. To do that we must create the function descriptor for our desired signature.  // Desired signature int Printable_printToFile(void* _self, FILE* fp);   Our descriptor will be called M_PRINTABLE_PRINT_TO_FILE, and it will be:   // Function descriptor for int Printable_printToFile(void* _self, FILE* fp); #define M_PRINTABLE_PRINT_TO_FILE_DEF int, Printable_printToFile #define M_PRINTABLE_PRINT_TO_FILE_ARG const void* _self, FILE* fp #define M_PRINTABLE_PRINT_TO_FILE_PARAM           _self,       fp   To declare that our interface exists we just have to call the INTERFACE_METHOD_DECLARATION(func_desc_) macro.   The Printable_print function can make use of the ``Printable_printToFile, just passing the stdout` as the output file.   static inline int Printable_print(const void* _self){     return Printable_printToFile(_self, stdout); }   With that our interfaces public interface is complete  // File: printable_interface.h #ifndef PRINTABLE_INTERFACE_H__ #define PRINTABLE_INTERFACE_H__  #include &lt;ooc.h&gt; #include &lt;stdio.h&gt;  /*------------------------------------------------*/ /*----- Interface methods declaration ------------*/ /*------------------------------------------------*/  // This method should print an object string representation // into the file descriptor passed into it. // It must return the number of bytes written if succesful, if an error // occurs it should return a negative value // Function descriptor for int Printable_printToFile(void* _self, FILE* fp); #define M_PRINTABLE_PRINT_TO_FILE_DEF int, Printable_printToFile #define M_PRINTABLE_PRINT_TO_FILE_ARG const void* _self, FILE* fp #define M_PRINTABLE_PRINT_TO_FILE_PARAM           _self,       fp INTERFACE_METHOD_DECLARATION(M_PRINTABLE_PRINT_TO_FILE);  //Shortcut for printing an object into the standart output. static inline int Printable_print(const void* _self){     return Printable_printToFile(_self, stdout); }  #endif //PRINTABLE_INTERFACE_H__   Interface implementation   To implement the interface you just have to use the INTERFACE_METHOD_IMPLEMENTATION(error_return_value_, func_desc_) macro. Its arguments are the value to return if the interface is called on something that doesn’t accept it and the function descriptor for that interface.   The final interface implementation is as follows  // File: printable_interface.c #include &lt;printable_interface.h&gt;  /*------------------------------------------------*/ /*----- Interface methods implementation ---------*/ /*------------------------------------------------*/ INTERFACE_METHOD_IMPLEMENTATION(-1, M_PRINTABLE_PRINT_TO_FILE);   Now to test this interface we will add it into the Point class we created earlier.   Adding the printable interface to the Point class  In order for a class to be able to implement an interface, it must have a metaclass. The interface methods are also overwritable by the base class subclasses.   To incorporate the interface into the class we will have to modify the tree files (public and reserved interfaces and the implementation).   Since Point already has the metaclass PointClass all we to do in the public interface is #include the printable interface and use the INTERFACE_METHOD_HEADER(metaclass_, func_desc_)macro.   INTERFACE_METHOD_HEADER(PointClass, M_PRINTABLE_PRINT_TO_FILE);   In the reserved interface we will have to add the interface to the metaclass representation and add the super method of the interface   typedef struct PointClass_r{     const Class_r _;     CLASS_DYNAMIC_METHOD(M_POINT_DRAW);     CLASS_INTERFACE_METHOD(PointClass, M_PRINTABLE_PRINT_TO_FILE); }PointClass_r;  SUPER_DYNAMIC_METHOD(M_POINT_DRAW); SUPER_INTERFACE_METHOD(PointClass, M_PRINTABLE_PRINT_TO_FILE);   We do that with the CLASS_INTERFACE_METHOD and the SUPER_INTERFACE_METHOD macros, they work exactly like their dynamic methods contraparts, but they also need the metaclass name as a parameter.   To finish thing up on the implementation file we will have to create the interface method itself, add the linkage into the metaclass constructor, overwrite the interface function and link the class to overwritten method.   INTERFACE_METHOD(PointClass, -1,  M_PRINTABLE_PRINT_TO_FILE);  static OVERWRITE_METHOD(Point, M_PRINTABLE_PRINT_TO_FILE){     CAST(self, Point);     ASSERT(self, -1);     return fprintf(fp, \"(%d, %d)\\n\", self-&gt;x, self-&gt;y); }  static OVERWRITE_METHOD(PointClass, M_CTOR){     SUPER_CTOR(self, PointClass);     SELECTOR_LOOP(         FIRST_SELECTOR(M_POINT_DRAW)         ADD_INTERFACE_SELECTOR(PointClass, M_PRINTABLE_PRINT_TO_FILE)     ) }  const void* initPoint(){     return ooc_new(\tPointClassClass(),             \"Point\",             ObjectClass(),             sizeof(Point_r),             LINK_METHOD(Point, M_CTOR),             LINK_METHOD(Point, M_POINT_DRAW),             LINK_INTERFACE_METHOD(Point, PointClass, M_PRINTABLE_PRINT_TO_FILE),             0); }   All this steps are the same we did when creating a dynamically linked method, The only difference is that some of the interface macros require the metaclass as its parameter aswell.   The complete modified files are:   // File: point.h #ifndef POINT_H_ #define POINT_H_  #include &lt;ooc.h&gt; #include &lt;printable_interface.h&gt;  /*------------------------------------------------*/ /*----------- ClassVar declaration ---------------*/ /*------------------------------------------------*/ CLASS_DECLARATION(Point); CLASS_DECLARATION(PointClass);  static inline o_Point Point(int x, int y){     return ooc_new(PointClass(), x, y); }  void Point_move(o_Point _self, int delta_x, int delta_y);   #define M_POINT_DRAW_DEF   void, Point_draw #define M_POINT_DRAW_ARG   o_Point _self #define M_POINT_DRAW_PARAM         _self DYNAMIC_METHOD_HEADER(M_POINT_DRAW);  INTERFACE_METHOD_HEADER(PointClass, M_PRINTABLE_PRINT_TO_FILE);  #endif   // File: point.r #ifndef POINT_R_ #define POINT_R_  #include &lt;point.h&gt; #include &lt;ooc.r&gt;  typedef struct Point_r{     const Object_r _;     int x;     int y; }Point_r;  typedef struct PointClass_r{     const Class_r _;     CLASS_DYNAMIC_METHOD(M_POINT_DRAW);     CLASS_INTERFACE_METHOD(PointClass, M_PRINTABLE_PRINT_TO_FILE); }PointClass_r;  SUPER_DYNAMIC_METHOD(M_POINT_DRAW); SUPER_INTERFACE_METHOD(PointClass, M_PRINTABLE_PRINT_TO_FILE);  #endif   // File: point.c #include &lt;point.h&gt; #include &lt;point.r&gt; #include &lt;lua_assert.h&gt;  DYNAMIC_METHOD(PointClass, , M_POINT_DRAW); INTERFACE_METHOD(PointClass, -1,  M_PRINTABLE_PRINT_TO_FILE);  void Point_move(o_Point _self, int delta_x, int delta_y){     CAST(self, Point);     ASSERT(self,);     self-&gt;x += delta_x;     self-&gt;y += delta_y; }  static OVERWRITE_METHOD(Point, M_POINT_DRAW){     CAST(self, Point);     ASSERT(self, );     printf(\"Point at %d, %d\\n\", self-&gt;x, self-&gt;y); }  static OVERWRITE_METHOD(Point, M_PRINTABLE_PRINT_TO_FILE){     CAST(self, Point);     ASSERT(self, -1);     return fprintf(fp, \"(%d, %d)\\n\", self-&gt;x, self-&gt;y); }  static OVERWRITE_METHOD(Point, M_CTOR){     SUPER_CTOR(self, Point);     ASSERT(self, NULL);     self-&gt;x = CTOR_GET_PARAM(int);     self-&gt;y = CTOR_GET_PARAM(int);     return self; }  static OVERWRITE_METHOD(PointClass, M_CTOR){     SUPER_CTOR(self, PointClass);     SELECTOR_LOOP(         FIRST_SELECTOR(M_POINT_DRAW)         ADD_INTERFACE_SELECTOR(PointClass, M_PRINTABLE_PRINT_TO_FILE)     ) }    const void* Point_d; const void* PointClass_d; const void* initPoint(){     return ooc_new(\tPointClassClass(),             \"Point\",             ObjectClass(),             sizeof(Point_r),             LINK_METHOD(Point, M_CTOR),             LINK_METHOD(Point, M_POINT_DRAW),             LINK_INTERFACE_METHOD(Point, PointClass, M_PRINTABLE_PRINT_TO_FILE),             0); } const void* initPointClass(){     return ooc_new(\tClassClass(),             \"PointClass\",             ClassClass(),             sizeof(PointClass_r),             LINK_METHOD(PointClass, M_CTOR),             0); }   In short:                  Dynamic method       Interface                       DYNAMIC_METHOD_HEADER(func_desc_)       INTERFACE_METHOD_HEADER(metaclass_, func_desc_)                 CLASS_DYNAMIC_METHOD(func_desc_)       CLASS_INTERFACE_METHOD(metaclass_, func_desc_)                 SUPER_DYNAMIC_METHOD(func_desc_)       SUPER_INTERFACE_METHOD(metaclass_, func_desc_)                 DYNAMIC_METHOD(metaclass_, error_return_value_, func_desc_)       INTERFACE_METHOD(metaclass_, error_return_value_, func_desc_)                 OVERWRITE_METHOD(class_, func_desc_)       OVERWRITE_METHOD(class_, func_desc_)                 FIRST_SELECTOR(func_desc_)       FIRST_INTERFACE_SELECTOR(metaclass_, func_desc_)                 ADD_SELECTOR(func_desc_)       ADD_INTERFACE_SELECTOR(metaclass_, func_desc_)                 LINK_METHOD(class_, func_desc_)       LINK_INTERFACE_METHOD(class_, metaclass_, func_desc_)           All done, we can now use the printable interface in Point objects and all its subclasses.   If we run:      o_Point o_point = Point(3,5);     o_Circle o_circle = Circle(4,3, 10);     Point_draw(o_point);     Point_move(o_point, 10, 10);     Point_draw(o_point);     Point_move(o_point, -15, -20);     Point_draw(o_point);     Point_draw(o_circle);     Point_move(o_circle, 7, 2);     Point_draw(o_circle);     Point_move(o_circle, -3, 30);     Point_draw(o_circle);     Printable_print(o_point);     Printable_print(o_circle);     OOC_DELETE(o_point);     OOC_DELETE(o_circle);  The output will be  Point at 3, 5 Point at 13, 15 Point at -2, -5 Circle with radius 10 at 4, 3 Circle with radius 10 at 11, 5 Circle with radius 10 at 8, 35 (-2, -5) (8, 35)   Overwriting the interface behaviour in Circle   As we can see the circle and point calls to Printable_print returned the same thing. That’s because when a subclass does not overwrite the base class method, it will default to the base class behaviour.   If we want to change that behaviour we just have to overwrite the behaviour in the circle implementation.   Just add   static OVERWRITE_METHOD(Circle, M_PRINTABLE_PRINT_TO_FILE){     CAST(self, Circle);     ASSERT(self, -1);     return fprintf(fp, \"(%d, %d)r:%d\\n\", ((Point_r*)self)-&gt;x, ((Point_r*)self)-&gt;y, self-&gt;radius); }   and link the new interface method   const void* initCircle(){     return ooc_new(\tPointClassClass(),             \"Circle\",             PointClass(),             sizeof(Circle_r),             LINK_METHOD(Circle, M_CTOR),             LINK_METHOD(Circle, M_POINT_DRAW),             LINK_INTERFACE_METHOD(Circle, PointClass, M_PRINTABLE_PRINT_TO_FILE),             0); }   The complete file will look like this:  // File: circle.c #include \"circle.h\" #include \"circle.r\" #include \"lua_assert.h\"  static OVERWRITE_METHOD(Circle, M_POINT_DRAW){     CAST(self, Circle);     ASSERT(self, );     printf(\"Circle with radius %d at %d, %d\\n\", self-&gt;radius, self-&gt;_.x, self-&gt;_.y); }  static OVERWRITE_METHOD(Circle, M_PRINTABLE_PRINT_TO_FILE){     CAST(self, Circle);     ASSERT(self, -1);     return fprintf(fp, \"(%d, %d)r:%d\\n\", ((Point_r*)self)-&gt;x, ((Point_r*)self)-&gt;y, self-&gt;radius); }  static OVERWRITE_METHOD(Circle, M_CTOR){     SUPER_CTOR(self, Circle);     ASSERT(self, NULL);     self-&gt;radius = CTOR_GET_PARAM(int);     return self; }  const void* Circle_d; const void* initCircle(){     return ooc_new(\tPointClassClass(),             \"Circle\",             PointClass(),             sizeof(Circle_r),             LINK_METHOD(Circle, M_CTOR),             LINK_METHOD(Circle, M_POINT_DRAW),             LINK_INTERFACE_METHOD(Circle, PointClass, M_PRINTABLE_PRINT_TO_FILE),             0); }   The output of that same program will now be   Point at 3, 5 Point at 13, 15 Point at -2, -5 Circle with radius 10 at 4, 3 Circle with radius 10 at 11, 5 Circle with radius 10 at 8, 35 (-2, -5) (8, 35)r:10  ","categories": ["OOC"],
        "tags": ["c","OOC","Interface"],
        "url": "https://rodrigowerberich.github.io//ooc/interface/en",
        "teaser":null}]
